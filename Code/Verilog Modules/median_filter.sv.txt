module median_filter_bram #(
    parameter WIDTH = 640,
    parameter HEIGHT = 480
)(
    input wire clk,
    input wire rst_n,
    input wire start,

    // Input BRAM interface (read)
    output reg [15:0] in_addr,    // address to read pixel from input BRAM
    input wire [23:0] in_data,    // pixel data from input BRAM: {R[7:0], G[7:0], B[7:0]}

    // Output BRAM interface (write)
    output reg [15:0] out_addr,   // address to write pixel to output BRAM
    output reg [23:0] out_data,   // pixel data to write to output BRAM
    output reg out_we,            // write enable for output BRAM

    output reg done
);

    // States for FSM
    localparam IDLE   = 2'd0,
               READ   = 2'd1,
               SORT   = 2'd2,
               WRITE  = 2'd3;

    reg [1:0] state;
    reg [15:0] x, y;  // current pixel coordinate (excluding border pixels)

    // Window buffers for R,G,B (9 pixels)
    reg [7:0] window_r [0:8];
    reg [7:0] window_g [0:8];
    reg [7:0] window_b [0:8];

    // Brightness for sorting (R+G+B)
    reg [10:0] brightness [0:8]; // 8+8+8=24 bits actually, 11 bits sufficient if 3*255=765 max

    integer i, j;

    // Sorting indices
    reg [3:0] sort_i, sort_j;

    // Temp registers for swapping
    reg [10:0] temp_brightness;
    reg [7:0] temp_r, temp_g, temp_b;

    reg [3:0] pixel_count;  // for tracking how many pixels loaded for current window

    // Address calculation helper function
    function [15:0] addr_calc;
        input [15:0] x_in, y_in;
        begin
            addr_calc = y_in * WIDTH + x_in;
        end
    endfunction

    // For reading window pixels
    reg [3:0] read_pixel_idx;
    reg reading;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state <= IDLE;
            x <= 1;
            y <= 1;
            done <= 0;
            in_addr <= 0;
            out_addr <= 0;
            out_data <= 0;
            out_we <= 0;
            reading <= 0;
            pixel_count <= 0;
            sort_i <= 0;
            sort_j <= 0;
        end else begin
            case(state)
                IDLE: begin
                    done <= 0;
                    out_we <= 0;
                    if (start) begin
                        x <= 1; 
                        y <= 1;
                        state <= READ;
                        reading <= 1;
                        read_pixel_idx <= 0;
                    end
                end

                READ: begin
                    if (reading) begin
                        // Calculate pixel coordinates for window pixel
                        // The window pixels go from y-1 to y+1, x-1 to x+1
                        // pixel index maps to (row, col) in 3x3 window:
                        // idx = row * 3 + col;
                        // row = idx / 3, col = idx % 3;
                        reg [15:0] wx, wy;
                        wy = y + (read_pixel_idx / 3) - 1;
                        wx = x + (read_pixel_idx % 3) - 1;
                        in_addr <= addr_calc(wx, wy);
                        
                        // After one cycle, input pixel data available (assume BRAM read latency = 1 clk)
                        if (read_pixel_idx > 0) begin
                            // Store previous pixel data read in last cycle
                            window_r[read_pixel_idx-1] <= in_data[23:16];
                            window_g[read_pixel_idx-1] <= in_data[15:8];
                            window_b[read_pixel_idx-1] <= in_data[7:0];
                            brightness[read_pixel_idx-1] <= in_data[23:16] + in_data[15:8] + in_data[7:0];
                        end
                        
                        read_pixel_idx <= read_pixel_idx + 1;

                        if (read_pixel_idx == 9) begin
                            // Store last pixel read
                            window_r[8] <= in_data[23:16];
                            window_g[8] <= in_data[15:8];
                            window_b[8] <= in_data[7:0];
                            brightness[8] <= in_data[23:16] + in_data[15:8] + in_data[7:0];
                            reading <= 0;
                            sort_i <= 0;
                            sort_j <= 0;
                            state <= SORT;
                        end
                    end
                end

                SORT: begin
                    // Bubble sort brightness & corresponding RGB
                    if (sort_i < 8) begin
                        if (sort_j < 8 - sort_i) begin
                            if (brightness[sort_j] > brightness[sort_j+1]) begin
                                // Swap brightness
                                temp_brightness = brightness[sort_j];
                                brightness[sort_j] = brightness[sort_j+1];
                                brightness[sort_j+1] = temp_brightness;

                                // Swap R
                                temp_r = window_r[sort_j];
                                window_r[sort_j] = window_r[sort_j+1];
                                window_r[sort_j+1] = temp_r;

                                // Swap G
                                temp_g = window_g[sort_j];
                                window_g[sort_j] = window_g[sort_j+1];
                                window_g[sort_j+1] = temp_g;

                                // Swap B
                                temp_b = window_b[sort_j];
                                window_b[sort_j] = window_b[sort_j+1];
                                window_b[sort_j+1] = temp_b;
                            end
                            sort_j <= sort_j + 1;
                        end else begin
                            sort_j <= 0;
                            sort_i <= sort_i + 1;
                        end
                    end else begin
                        // Sorting done, write median pixel (index 4)
                        out_addr <= addr_calc(x,y);
                        out_data <= {window_r[4], window_g[4], window_b[4]};
                        out_we <= 1;
                        state <= WRITE;
                    end
                end

                WRITE: begin
                    out_we <= 0;
                    // Move to next pixel
                    if (x < WIDTH - 2) begin
                        x <= x + 1;
                    end else begin
                        x <= 1;
                        if (y < HEIGHT - 2) begin
                            y <= y + 1;
                        end else begin
                            done <= 1;
                            state <= IDLE;
                        end
                    end
                    // Next pixel, go back to read
                    state <= (done) ? IDLE : READ;
                    reading <= 1;
                    read_pixel_idx <= 0;
                end

            endcase
        end
    end

endmodule
